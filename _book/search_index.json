[
["prepare-data-for-meta-analysis.html", "4 Prepare data for meta-analysis 4.1 Set environment and import data 4.2 Standardising sample variance 4.3 Reduce data set to required variables 4.4 Test dose effect 4.5 AUDPC visualise raw data", " 4 Prepare data for meta-analysis 4.1 Set environment and import data source(&quot;R/import_data.R&quot;) PM_MB_means &lt;- import_data() source(&quot;R/same.R&quot;) # matches each element of a vector and does not return NAs 4.2 Standardising sample variance Meta-analyses use variance from the data to calculate the effect sizes. The type of variance needs to be the same across all the data incorporated in the meta-analysis. We are narrowing the meta-analysis to only include treatments using demethylation inhibitors, tebuconazole and propiconazole. Lets look at what type of statistical error was reported for the trials that used these fungicides. PM_MB_means %&gt;% filter(fungicide_ai == &quot;tebuconazole&quot; | fungicide_ai == &quot;propiconazole&quot;) %&gt;% group_by(trial_ref, location, Y_error_type, fungicide_ai) %&gt;% summarise(DMI_treatments = length(Y_error_type)) %&gt;% arrange(Y_error_type) %&gt;% select(!fungicide_ai)%&gt;% kable(caption = &quot;Number of treatments for each trial and the error type reported&quot;, align = &quot;c&quot;) %&gt;% footnote(general = &quot;DMI - demethylation inhibitors (tebuconazole and propiconazole).&quot;) (#tab:variance_types)Number of treatments for each trial and the error type reported trial_ref location Y_error_type DMI_treatments mung1112/02 Kingaroy lsd (P=0.05) 4 mung1112/02 Kingaroy lsd (P=0.05) 2 AM1303 Premer stdev 3 AM1304 Marys Mount stdev 3 AM1305 Goolhi stdev 3 BB1305 Millmerran stdev 3 mung1011/01 Hermitage stdev 2 mung1011/02 Kingaroy stdev 6 mung1415/01 Hermitage stdev 5 mung1516/01 Hermitage stdev 6 mung1516/02 Kingaroy stdev 6 mung1617/01 Hermitage stdev 15 mung1617/01 Hermitage stdev 15 mung1617/02 Missen Flats stdev 15 mung1617/02 Missen Flats stdev 15 mung1718/01 Wellcamp stdev 6 mung1718/01 Wellcamp stdev 6 mung1819/01 Hermitage stdev 3 mung1819/02 Hermitage stdev 3 mung1112/01 Gatton NA 4 mung1112/01 Gatton NA 2 mung1516/03 Emerald NA 6 Note: DMI - demethylation inhibitors (tebuconazole and propiconazole). The experiment summaries report either standard deviation, least square differences or no error term (NA). First we will convert LSD and standard deviation to sample variance. Then we will impute variances for the trials which did not report any form of variance (NA). 4.2.1 Converting least-squares to sample variance First lets get a list the of trials that reported LSD. Trials &lt;- PM_MB_means %&gt;% filter(Y_error_type == &quot;lsd (P=0.05)&quot;) %&gt;% select(trial_ref) %&gt;% distinct() We will follow the method of converting ‘least square differences’ (LSD) to sampling variance reported by Nugugi et.al (2011). A table of T-critical values was consulted to select the T-crit value in the equation. Our data contained 30 degrees of freedom which equates to a ‘T-crit’ value of 1.697. Calculating sampling variance from mean squared error Paul et al. (2008) for (Trial2012 in Trials$trial_ref) { Tcrit &lt;- 1.697 # 0.05 and DFw = 30 # T critical value for which there is significant difference between two groups; This value is the same for both trials &quot;mung1112/01&quot; and &quot;mung1112/02&quot; DFw &lt;- sum(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) - length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) # degrees of freedom within groups LSD &lt;- PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error[1] V_yield &lt;- (PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[1] * (LSD / Tcrit) ^ 2) / 2 # method - Nugugi et.al (2011) DOI: 10.1094/phyto-08-10-0221 for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates)) { if (j == 1) { Sv &lt;- vector(length = length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates)) } # reset Sv vector if this is the first loop Sv[j] = V_yield / PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[j] } # Replace the values in the dataset PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error &lt;- Sv PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$Y_error_type &lt;- &quot;SamplingVariance&quot; } 4.2.2 Converting standard deviation to sample variance Now to estimate the variance from the standard deviation # subset data by those which describe the Yield error with standard deviation Trials &lt;- PM_MB_means %&gt;% filter(Y_error_type == &quot;stdev&quot;) %&gt;% select(trial_ref) %&gt;% distinct() # calculate the Sampling variance from the standard deviation # standard error of the mean equals the standard deviation divided by the square root of the number of samples # Sv &lt;- sem^2 &lt;- stdev/sqrt(n) # Sampling variance equals the square of the standard error. # Sv &lt;- (stdev/sqrt(n))^2 # Therefore for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error)) { if (j == 1) { Sv &lt;- vector(length = length(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error)) }# create empty vector at first iteration with length of j Sv[j] = (PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error[j]) ^ 2 } # and replacing the values in the dataset PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error &lt;- Sv PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$Y_error_type &lt;- &quot;SamplingVariance&quot; 4.3 Reduce data set to required variables Let’s tidy up the data set into a data frame of only the variables which are required for the analysis. First remove the irrelevant columns/variables. Then calculate fungicide application timing variables relative to the first sign of disease. Entries with NA in the grain yield or powdery mildew severity are also removed from the data. source(&quot;R/slimming_PM_dat.R&quot;) # see R script for the code which reduces the data. slim_PM_dat %&lt;&gt;% mutate(fungicide_timing_1 = fungicide_application_1 - first_sign_disease) %&gt;% mutate(fungicide_timing_2 = fungicide_application_2 - fungicide_application_1) %&gt;% mutate(fungicide_timing_3 = fungicide_application_3 - fungicide_application_2) %&gt;% filter(!is.na(grain_yield.t.ha)) %&gt;% filter(!is.na(PM_final_severity)) 4.3.1 Cluster fungicide applications We are going to define ‘fungicide application timing’ as a categorical variable, relative to the first sign of powdery mildew. These categorical variables are named: - Early: First fungicide application was prior to first sign of disease. - Recommended: First fungicide application was applied on the day powdery mildew was observed, or within three days of first sign. - Late: First fungicide application was four or more days after first sign of disease being observed. Follow up fungicide applications (cluster_2 and cluster_3) were also categorised as either, early, recommended or late. slim_PM_dat %&lt;&gt;% mutate( cluster_1 = case_when( fungicide_timing_1 &lt; 0 ~ &quot;Early&quot;, fungicide_timing_1 &gt;= 0 &amp; fungicide_timing_1 &lt; 4 ~ &quot;Recommended&quot;, TRUE ~ &quot;Late&quot; ) ) %&gt;% mutate( cluster_2 = case_when( is.na(fungicide_timing_2) ~ NA_character_, fungicide_timing_2 &lt; 13 ~ &quot;Early&quot;, fungicide_timing_2 &gt;= 13 &amp; fungicide_timing_2 &lt; 17 ~ &quot;Recommended&quot;, TRUE ~ &quot;Late&quot; ) ) %&gt;% mutate( cluster_3 = case_when( fungicide_timing_3 &lt; 14 ~ &quot;Early&quot;, is.na(fungicide_timing_3) ~ NA_character_, TRUE ~ &quot;Recommended&quot; ) ) Let’s look at these clusters to see where we have the most degrees of freedom. clusters &lt;- unique(slim_PM_dat[c(&quot;cluster_1&quot;, &quot;cluster_2&quot;, &quot;cluster_3&quot;)]) for (i in 1:nrow(clusters)) { if (i == 1) { clusters$n &lt;- NA clusters$n_x_trial &lt;- NA } clusters[i, &quot;n&quot;] &lt;- nrow(slim_PM_dat[same(slim_PM_dat$cluster_1, clusters[i, &quot;cluster_1&quot;]) &amp; same(slim_PM_dat$cluster_2, clusters[i, &quot;cluster_2&quot;]) &amp; same(slim_PM_dat$cluster_3, clusters[i, &quot;cluster_3&quot;]),]) clusters[i, &quot;n_x_trial&quot;] &lt;- length(unique(slim_PM_dat[same(slim_PM_dat$cluster_1, clusters[i, &quot;cluster_1&quot;]) &amp; same(slim_PM_dat$cluster_2, clusters[i, &quot;cluster_2&quot;]) &amp; same(slim_PM_dat$cluster_3, clusters[i, &quot;cluster_3&quot;]), &quot;trial_ref&quot;])) } knitr::kable(clusters) cluster_1 cluster_2 cluster_3 n n_x_trial 1 Late NA NA 57 17 2 Recommended NA NA 32 15 9 Recommended Late NA 12 4 11 Early Late Early 2 1 15 Recommended Recommended NA 30 10 30 Recommended Late Early 1 1 33 Recommended Early NA 1 1 34 Recommended Early Early 1 1 36 Early NA NA 13 3 37 Early Late NA 1 1 38 Early Late Recommended 1 1 42 Recommended Recommended Recommended 1 1 44 Early Recommended Recommended 1 1 48 Late Recommended NA 6 4 59 Late Recommended Recommended 2 2 148 Late Late NA 12 1 From this we can see that there are 16 different cluster combinations, which would make the analysis too difficult. We will reduce this to 6 levels within one variable. Single sprays either: a) early, b) recommended timing, c) late. Two or more sprays where the first spray was either: d) early, e) recommended timing, f) late. slim_PM_dat &lt;- slim_PM_dat %&gt;% mutate( spray_management = case_when( fungicide_timing_1 &lt; 0 &amp; is.na(fungicide_application_2) &amp; is.na(fungicide_application_3) ~ &quot;Early&quot;, fungicide_timing_1 &gt;= 0 &amp; fungicide_timing_1 &lt; 4 &amp; is.na(fungicide_application_2) &amp; is.na(fungicide_application_3) ~ &quot;Recommended&quot;, fungicide_timing_1 &gt;= 4 &amp; is.na(fungicide_application_2) &amp; is.na(fungicide_application_3) ~ &quot;Late&quot;, fungicide_timing_1 &lt; 0 &amp; !is.na(fungicide_application_2) ~ &quot;Early_plus&quot;, fungicide_timing_1 &gt;= 0 &amp; fungicide_timing_1 &lt; 4 &amp; !is.na(fungicide_application_2) ~ &quot;Recommended_plus&quot;, fungicide_timing_1 &gt;= 4 &amp; !is.na(fungicide_application_2) ~ &quot;Late_plus&quot;, TRUE ~ &quot;Other&quot; ) ) slim_PM_dat[slim_PM_dat$fungicide_ai == &quot;control&quot;, c( &quot;fungicide_timing_1&quot;, &quot;fungicide_timing_2&quot;, &quot;fungicide_timing_3&quot;, &quot;spray_management&quot; )] &lt;- &quot;control&quot; Now to view the number break-down of the spray_management treatments table(slim_PM_dat$spray_management) ## ## control Early Early_plus Late ## 40 13 5 17 ## Late_plus Recommended Recommended_plus ## 20 32 46 There are few ‘Early_plus’ treatments, these treatments therefore will have too few comparisons with other treatments in the meta-analysis to provide accurate results. Therefore we will remove ‘Early_plus’ from the analysis. slimmer_PM_dat &lt;- slim_PM_dat[slim_PM_dat$spray_management != &quot;Early_plus&quot;, ] 4.4 Test dose effect Earlier we noted there were different doses of propiconazole which might influence our analysis. Lets check this by comparing a linear mixed effect model including and excluding dose. We already have a factor breaking down the dose in the trial variable, lets make a new one without dose. slimmer_PM_dat$trial_noDose &lt;- paste(slimmer_PM_dat$trial_ref, slimmer_PM_dat$year, slimmer_PM_dat$location,slimmer_PM_dat$host_genotype, slimmer_PM_dat$row_spacing,sep = &quot;_&quot;) cbind(Dose = head(slimmer_PM_dat$trial), NoDose = head(slimmer_PM_dat$trial_noDose)) %&gt;% kable() Dose NoDose mung1011/01_2011_Hermitage_Berken_0.75_lowDose mung1011/01_2011_Hermitage_Berken_0.75 mung1011/01_2011_Hermitage_Berken_0.75_lowDose mung1011/01_2011_Hermitage_Berken_0.75 mung1011/01_2011_Hermitage_Crystal_0.75_lowDose mung1011/01_2011_Hermitage_Crystal_0.75 mung1011/01_2011_Hermitage_Crystal_0.75_lowDose mung1011/01_2011_Hermitage_Crystal_0.75 mung1011/02_2011_Kingaroy_Berken_0.75_lowDose mung1011/02_2011_Kingaroy_Berken_0.75 mung1011/02_2011_Kingaroy_Crystal_0.75_lowDose mung1011/02_2011_Kingaroy_Crystal_0.75 Lets test the in a basic linear mixed effect model m1 &lt;- lmer(log(grain_yield.t.ha * 1000) ~ factor(spray_management) + (1 | trial), data = slimmer_PM_dat) m2 &lt;- lmer(log(grain_yield.t.ha * 1000) ~ factor(spray_management) + (1 | trial_noDose), data = slimmer_PM_dat) anova(m1,m2) ## refitting model(s) with ML (instead of REML) ## Data: slimmer_PM_dat ## Models: ## m1: log(grain_yield.t.ha * 1000) ~ factor(spray_management) + (1 | ## m1: trial) ## m2: log(grain_yield.t.ha * 1000) ~ factor(spray_management) + (1 | ## m2: trial_noDose) ## npar AIC BIC logLik deviance Chisq Df Pr(&gt;Chisq) ## m1 8 -21.404 3.588 18.702 -37.404 ## m2 8 -60.156 -35.165 38.078 -76.156 38.753 0 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Using the model without dose produces a better fit, as shown by the lower AIC and is significantly different from the model m1. We will remove the dose term from the trial grouping. slimmer_PM_dat$trial &lt;- slimmer_PM_dat$trial_noDose slimmer_PM_dat &lt;- slimmer_PM_dat[,colnames(slimmer_PM_dat) != &quot;trial_noDose&quot;] #remove second trial column write.csv(slimmer_PM_dat, file = &quot;cache/slimmer_PM_clusterdat.csv&quot;, row.names = FALSE) Our data currently uses sample variance to define the yield error. We should expect that when yield increases so does the variance. Let’s quickly plot this to check. # redefine sample variance calculated from mean square slimmer_PM_dat$vi &lt;- slimmer_PM_dat$Y_Msquare / (slimmer_PM_dat$n * slimmer_PM_dat$grain_yield.t.ha ^ 2) slimmer_PM_dat %&gt;% ggplot(aes(x = grain_yield.t.ha, y = vi)) + geom_point() ## Warning: Removed 21 rows containing missing values (geom_point). We see here that the sample variance generally decreases or has no association with the grain yield. This might be due to the unpredictable nature of mungbeans, however going forward we will use mean squares which defines between trial variation and is a the more generic error term. slimmer_PM_dat %&gt;% ggplot(aes(x = grain_yield.t.ha, y = Y_Msquare)) + geom_point() ## Warning: Removed 21 rows containing missing values (geom_point). 4.5 AUDPC visualise raw data How well does ‘area under the disease progress curve’ (AUDPC) predict grain yield? and Does spray_management scenario mitigate yield loss through reducing AUDPC? We would expect to see grain yield decline with increasing AUDPC. Let’s just plot yield vs AUDPC. plot(grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means) abline(lm(grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means)) There appears to be a weak positive relationship between the two continuous variables. Does a linear model confirm this? summary(lm(grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means)) ## ## Call: ## lm(formula = grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.97576 -0.52647 -0.03467 0.44671 1.37851 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.0736621 0.0659923 16.269 &lt;2e-16 *** ## AUDPC_m 0.0009391 0.0004736 1.983 0.0485 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5845 on 249 degrees of freedom ## (104 observations deleted due to missingness) ## Multiple R-squared: 0.01555, Adjusted R-squared: 0.01159 ## F-statistic: 3.932 on 1 and 249 DF, p-value: 0.04846 This is not what we would expect and the low R squared value of 0.012 perhaps there are additional factors influencing this relationship. Lets tease out variation due to trial location, season, row spacing, and other seasonal variables are preventing us from seeing the expected relationship. Let’s do the plot again for each trial where there are no missing values. Note: The plots are ordered by mean yield of the trial. sm2lg &lt;- PM_MB_means %&gt;% group_by(trial_ref) %&gt;% summarise(TY = mean(grain_yield.t.ha., na.rm = TRUE)) %&gt;% arrange(TY) for (i in sm2lg$trial_ref) { dat1 &lt;- PM_MB_means[PM_MB_means$trial_ref == i, ] if (any(is.na(dat1$grain_yield.t.ha.))) { next } if (any(is.na(dat1$AUDPC_m))) { next } plot( grain_yield.t.ha. ~ AUDPC_m, data = dat1, main = paste(dat1$location[1], (dat1$year[1])), ylim = c(0, max(PM_MB_means$grain_yield.t.ha., na.rm = TRUE)), xlim = c(0, max(PM_MB_means$AUDPC_m, na.rm = TRUE)) ) abline(lm(grain_yield.t.ha. ~ AUDPC_m, data = dat1)) points(grain_yield.t.ha. ~ AUDPC_m, data = dat1[dat1$fungicide_ai == &quot;control&quot;,], col = &quot;red&quot;) } This sequence of graphs show that AUDPC and disease incidence tends not impact on yields if the season is a low yielding, ie lower than 1 tonne per hectare. The higher the yield the greater greater the influence on the disease on the yield especially if the crop is high yielding with AUDPC also being large enough to reduce yield. Let’s have a look again at the same sequence of graphs and analyses for area under the disease progress stairs. plot(grain_yield.t.ha. ~ AUDPS_m, data = PM_MB_means) abline(lm(grain_yield.t.ha. ~ AUDPS_m, data = PM_MB_means)) summary(lm(grain_yield.t.ha. ~ AUDPS_m, data = PM_MB_means)) ## ## Call: ## lm(formula = grain_yield.t.ha. ~ AUDPS_m, data = PM_MB_means) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.96737 -0.53252 -0.02247 0.45143 1.38925 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.0695629 0.0715415 14.950 &lt;2e-16 *** ## AUDPS_m 0.0008235 0.0004481 1.838 0.0673 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5852 on 249 degrees of freedom ## (104 observations deleted due to missingness) ## Multiple R-squared: 0.01338, Adjusted R-squared: 0.00942 ## F-statistic: 3.377 on 1 and 249 DF, p-value: 0.06728 sm2lg &lt;- PM_MB_means %&gt;% group_by(trial_ref) %&gt;% summarise(TY = mean(grain_yield.t.ha., na.rm = TRUE)) %&gt;% arrange(TY) for (i in sm2lg$trial_ref) { dat1 &lt;- PM_MB_means[PM_MB_means$trial_ref == i,] if (any(is.na(dat1$grain_yield.t.ha.))) { next } if (any(is.na(dat1$AUDPS_m))) { next } plot( grain_yield.t.ha. ~ AUDPS_m, data = dat1, main = paste(dat1$location[1], (dat1$year[1])), ylim = c(0, max( PM_MB_means$grain_yield.t.ha., na.rm = TRUE )), xlim = c(0, max(PM_MB_means$AUDPS_m, na.rm = TRUE)) ) abline(lm(grain_yield.t.ha. ~ AUDPS_m, data = dat1)) points(grain_yield.t.ha. ~ AUDPS_m, data = dat1[dat1$fungicide_ai == &quot;control&quot;, ], col = &quot;red&quot;) } The plots from the AUPDS is similar to the AUDPC, however according to the linear model the AUDPC is a better, significant fit. A mixed effect model would be more suitable to investigate the interactive effects of location, season, and trial. The mixed effect model will help us decide on the best approach and structure for our meta-analysis model. 4.5.1 Disease presure factor We may wish to investigate the impact of spray management in mitigating the yield loss through the effect on the disease pressure. We will set a categorical variable to indicate the amount of disease pressure in the trial, which will be evaluated on the control plot. We will create two categories, lowD and highD. We will use the median AUDPC to separate the trials into these two groups. slimmer_PM_dat &lt;- read.csv(here(&quot;cache/slimmer_PM_clusterdat.csv&quot;)) slimmer_PM_dat$D_pres &lt;- NA_character_ Trial_Dpress &lt;- slimmer_PM_dat %&gt;% group_by(trial_ref) %&gt;% filter(fungicide_ai == &quot;control&quot;) %&gt;% summarise(AUDPC_C = mean(AUDPC_m, na.rm = TRUE)) median_AUDPC &lt;- median(as.vector(Trial_Dpress$AUDPC_C), na.rm = TRUE) sort(Trial_Dpress$AUDPC_C) ## [1] 24.50000 40.25000 41.00000 47.12500 78.33333 82.60000 119.62500 ## [8] 153.62500 161.00000 172.00000 192.08333 198.72222 228.37037 239.61111 for(i in unique(slimmer_PM_dat$trial_ref)) { if (is.na(Trial_Dpress[Trial_Dpress$trial_ref == i, &quot;AUDPC_C&quot;])) { next() } if (Trial_Dpress[Trial_Dpress$trial_ref == i, &quot;AUDPC_C&quot;] &lt; median_AUDPC) { slimmer_PM_dat[slimmer_PM_dat$trial_ref == i, &quot;D_pres&quot;] &lt;- &quot;lowD&quot; } else{ if (Trial_Dpress[Trial_Dpress$trial_ref == i, &quot;AUDPC_C&quot;] &gt;= median_AUDPC) { slimmer_PM_dat[slimmer_PM_dat$trial_ref == i, &quot;D_pres&quot;] &lt;- &quot;highD&quot; } else{ slimmer_PM_dat[slimmer_PM_dat$trial_ref == i, &quot;D_pres&quot;] &lt;- NA_character_ } } } write.csv(slimmer_PM_dat, file = here(&quot;cache/slimmer_PM_clusterdat.csv&quot;), row.names = FALSE) Lets have a quick look to examine weather trials with high disease pressure sustain a greater yield loss. slimmer_PM_dat %&gt;% ggplot(aes(x = D_pres, y = grain_yield.t.ha))+ geom_boxplot() From this plot we see that in the trials with high disease pressure treatments on tended to produce lower yields. There are 3 trials that contained no data for AUDPC and thus produced NA values. "]
]
