# Prepare data for meta-analysis
## Set environment and import data  

```{r load_libraries, include=FALSE}
if (!require("pacman"))
   install.packages("pacman")
pacman::p_load(tidyverse, kableExtra, agricolae, lme4
)
```

```{r import_data}
source("R/import_data.R")
PM_MB_means <- import_data()

source("R/same.R") # matches each element of a vector and does not return NAs
```


## Standardising sample variance  
Meta-analyses use variance from the data to calculate the effect sizes. 
The type of variance needs to be the same across all the data incorporated in the meta-analysis.  

We are narrowing the meta-analysis to only include treatments using demethylation inhibitors, tebuconazole and propiconazole. 
Lets look at what type of statistical error was reported for the trials that used these fungicides.    

```{r variance_types}
PM_MB_means %>%
   filter(fungicide_ai == "tebuconazole" |
             fungicide_ai == "propiconazole") %>%
   group_by(trial_ref, location, Y_error_type, fungicide_ai) %>%
   summarise(DMI_treatments = length(Y_error_type)) %>%
   arrange(Y_error_type) %>%
   select(!fungicide_ai)%>%
   kable(caption = "Number of treatments for each trial and the error type reported", align = "c") %>%
   footnote(general = "DMI - demethylation inhibitors (tebuconazole and propiconazole).")
```

The experiment summaries report either standard deviation, least square differences or no error term (`NA`). 
First we will convert LSD and standard deviation to sample variance. 
Then we will impute variances for the trials which did not report any form of variance (`NA`).  



### Converting least-squares to sample variance  

First lets get a list the of trials that reported LSD.  
```{r all_LSD_trials}
Trials <- PM_MB_means %>%
   filter(Y_error_type == "lsd (P=0.05)") %>%
   select(trial_ref) %>%
   distinct()
```


We will follow the method of converting 'least square differences' (LSD) to sampling variance reported by [Nugugi et.al (2011)](https://apsjournals.apsnet.org/doi/10.1094/PHYTO-08-10-0221).
A [table of T-critical values](https://www.statisticshowto.datasciencecentral.com/tables/t-distribution-table/) was consulted to select the T-crit value in the equation. 
Our data contained 30 degrees of freedom which equates to a 'T-crit' value of 1.697.  

![Calculating sampling variance from mean squared error Paul et al. (2008)](Paul_etal_2008.PNG)  

```{r LSD_2_Sampling Variance}

for (Trial2012 in Trials$trial_ref) {
   Tcrit <-
      1.697  # 0.05 and DFw = 30 # T critical value for which there is significant difference between two groups; This value is the same for both trials "mung1112/01" and "mung1112/02"
   DFw <-
      sum(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) -
      length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) # degrees of freedom within groups
   
   LSD <-
      PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error[1]
   
   
   V_yield <-
      (PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[1] * (LSD /
                                                                             Tcrit) ^ 2) / 2 # method - Nugugi et.al (2011) DOI: 10.1094/phyto-08-10-0221
   
   
   for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates)) {
      if (j == 1) {
         Sv <-
            vector(length = length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates))
      } # reset Sv vector if this is the first loop
      
      
      Sv[j] = V_yield /
         PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[j]
      
   }
   
   # Replace the values in the dataset
   PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error <-
      Sv
   PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$Y_error_type <-
      "SamplingVariance"
   
}
```


### Converting standard deviation to sample variance
Now to estimate the variance from the standard deviation

```{r stdev2SampVariance}
# subset data by those which describe the Yield error with standard deviation
Trials <- PM_MB_means %>%
   filter(Y_error_type == "stdev") %>%
   select(trial_ref) %>%
   distinct()


# calculate the Sampling variance from the standard deviation
# standard error of the mean equals the standard deviation divided by the square root of the number of samples
# Sv <- sem^2 <- stdev/sqrt(n)
# Sampling variance equals the square of the standard error.
# Sv <- (stdev/sqrt(n))^2

# Therefore

for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error)) {
   if (j == 1) {
      Sv <-
         vector(length = length(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error))
   }# create empty vector at first iteration with length of j
   
   Sv[j] = (PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error[j]) ^ 2
}



# and replacing the values in the dataset
PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$yield_error <-
   Sv
PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref, ]$Y_error_type <-
   "SamplingVariance"
```




## Reduce data set to required variables  
Let's tidy up the data set into a data frame of only the variables which are required for the analysis.  

First remove the irrelevant columns/variables. Then calculate fungicide application timing variables relative to the first sign of disease. Entries with NA in the grain yield or powdery mildew severity are also removed from the data.    

```{r clustered_fungicide_applications}
source("R/slimming_PM_dat.R") # see R script for the code which reduces the data.

slim_PM_dat %<>%
   mutate(fungicide_timing_1 = fungicide_application_1 - first_sign_disease) %>%
   mutate(fungicide_timing_2 = fungicide_application_2 - fungicide_application_1) %>%
   mutate(fungicide_timing_3 = fungicide_application_3 - fungicide_application_2) %>%
   filter(!is.na(grain_yield.t.ha)) %>%
   filter(!is.na(PM_final_severity))

```

### Cluster fungicide applications  
We are going to define 'fungicide application timing' as a categorical variable, relative to the first sign of powdery mildew.  

These categorical variables are named:  
   - **Early**: First fungicide application was prior to first sign of disease.  
   - **Recommended**: First fungicide application was applied on the day powdery mildew was observed, or within three days of first sign.  
   - **Late**: First fungicide application was four or more days after first sign of disease being observed.  

Follow up fungicide applications (cluster_2 and cluster_3) were also categorised as either, early, recommended or late.  

```{r cluster}
slim_PM_dat %<>%
   mutate(
      cluster_1 = case_when(
         fungicide_timing_1 < 0 ~ "Early",
         fungicide_timing_1 >= 0 &
            fungicide_timing_1 < 4 ~ "Recommended",
         TRUE ~ "Late"
      )
   ) %>%
   mutate(
      cluster_2 = case_when(
         is.na(fungicide_timing_2) ~ NA_character_,
         fungicide_timing_2 < 13 ~ "Early",
         fungicide_timing_2 >= 13 &
            fungicide_timing_2 < 17 ~ "Recommended",
         TRUE ~ "Late"
      )
   ) %>%
   mutate(
      cluster_3 = case_when(
         fungicide_timing_3 < 14 ~ "Early",
         is.na(fungicide_timing_3) ~ NA_character_,
         TRUE ~ "Recommended"
      )
   )
```

Let's look at these clusters to see where we have the most degrees of freedom.

```{r cluster_clusters, warning=FALSE}
clusters <-
   unique(slim_PM_dat[c("cluster_1", "cluster_2", "cluster_3")])

for (i in 1:nrow(clusters)) {
   if (i == 1) {
      clusters$n <- NA
      clusters$n_x_trial <- NA
   }
   
   clusters[i, "n"] <-
      nrow(slim_PM_dat[same(slim_PM_dat$cluster_1, clusters[i, "cluster_1"]) &
                          same(slim_PM_dat$cluster_2, clusters[i, "cluster_2"]) &
                          same(slim_PM_dat$cluster_3, clusters[i, "cluster_3"]),])
   
   clusters[i, "n_x_trial"] <-
      length(unique(slim_PM_dat[same(slim_PM_dat$cluster_1, clusters[i, "cluster_1"]) &
                                   same(slim_PM_dat$cluster_2, clusters[i, "cluster_2"]) &
                                   same(slim_PM_dat$cluster_3, clusters[i, "cluster_3"]),
                                "trial_ref"]))
   
}

knitr::kable(clusters)
```

From this we can see that there are 16 different cluster combinations, which would make the analysis too difficult. We will reduce this to 6 levels within one variable.  

Single sprays of either:  
   a) early,  
   b) recommended timing,  
   c) late.  

Two or more sprays where the first spray was either:  
   d) early,  
   e) recommended timing,  
   f) late.

```{r simple_clusters}
slim_PM_dat <- slim_PM_dat %>%
   mutate(
      spray_management = case_when(
         fungicide_timing_1 < 0 &
            is.na(fungicide_application_2) &
            is.na(fungicide_application_3) ~ "Early",
         fungicide_timing_1 >= 0 &
            fungicide_timing_1 < 4 &
            is.na(fungicide_application_2) &
            is.na(fungicide_application_3) ~ "Recommended",
         fungicide_timing_1 >= 4 &
            is.na(fungicide_application_2) &
            is.na(fungicide_application_3) ~ "Late",
         fungicide_timing_1 < 0 &
            !is.na(fungicide_application_2) ~ "Early_plus",
         fungicide_timing_1 >= 0 &
            fungicide_timing_1 < 4 &
            !is.na(fungicide_application_2) ~ "Recommended_plus",
         fungicide_timing_1 >= 4 &
            !is.na(fungicide_application_2) ~ "Late_plus",
         TRUE ~ "Other"
      )
   )

slim_PM_dat[slim_PM_dat$fungicide_ai == "control",
            c(
               "fungicide_timing_1",
               "fungicide_timing_2",
               "fungicide_timing_3",
               "spray_management"
            )] <- "control"
```

Now to view the number break-down of the `spray_management` treatments

```{r tableSprayManagement}
table(slim_PM_dat$spray_management)
```

There are few 'Early_plus' treatments, these treatments therefore will have too few comparisons with other treatments in the meta-analysis to provide accurate results. Therefore we will remove 'Early_plus' from the analysis.  


```{r simpler_clusters_REMOVE}
slimmer_PM_dat <-
   slim_PM_dat[slim_PM_dat$spray_management != "Early_plus", ]

```

## Test dose effect

Earlier we noted there were different doses of propiconazole which might influence our analysis. 
Lets check this by comparing a linear mixed effect model including and excluding dose. 
We already have a factor breaking down the dose in the `trial` variable, lets make a new one without dose.

```{r dose_test}
slimmer_PM_dat$trial_noDose <- paste(slimmer_PM_dat$trial_ref, slimmer_PM_dat$year,
                 slimmer_PM_dat$location,slimmer_PM_dat$host_genotype,
                 slimmer_PM_dat$row_spacing,sep = "_")

cbind(Dose = head(slimmer_PM_dat$trial),
      NoDose = head(slimmer_PM_dat$trial_noDose)) %>%
   kable()
```

Lets test the dose effect in a basic linear mixed effect model

```{r dose_lmer}

m1 <-
   lmer(log(grain_yield.t.ha * 1000) ~ factor(spray_management) +
           (1 | trial),
        data = slimmer_PM_dat)

m2 <-
   lmer(log(grain_yield.t.ha * 1000) ~ factor(spray_management) +
           (1 | trial_noDose),
        data = slimmer_PM_dat)

anova(m1,m2)


```

Using the model without dose produces a better fit, as shown by the lower AIC and is significantly different from the model `m1`. 
We will remove the dose term from the trial grouping.

```{r}
slimmer_PM_dat$trial <- slimmer_PM_dat$trial_noDose
slimmer_PM_dat <- slimmer_PM_dat[,colnames(slimmer_PM_dat) != "trial_noDose"] #remove second trial column
write.csv(slimmer_PM_dat, file = "cache/slimmer_PM_clusterdat.csv", row.names = FALSE)
```



Our data currently uses sample variance to define the yield error. We should expect that when yield increases so does the variance. Let's quickly plot this to check.

```{r Var_mean_sqaures}
# redefine sample variance calculated from mean square
slimmer_PM_dat$vi <-
   slimmer_PM_dat$Y_Msquare /
   (slimmer_PM_dat$n * slimmer_PM_dat$grain_yield.t.ha ^ 2)

slimmer_PM_dat %>%
   ggplot(aes(x = grain_yield.t.ha, y = vi)) +
   geom_point()
```

We see here that the sample variance generally decreases or has no association with the grain yield. This might be due to the unpredictable nature of mungbeans, however going forward we will use mean squares which defines between trial variation and is a the more generic error term.  

```{r Var_MeanSquarePlot}
slimmer_PM_dat %>%
   ggplot(aes(x = grain_yield.t.ha, y = Y_Msquare)) +
   geom_point()
```

&nbsp;  
&nbsp;  
&nbsp;  

## AUDPC visualise raw data  

>How well does 'area under the disease progress curve' (AUDPC) predict grain yield?  

and _Does spray_management scenario mitigate yield loss through reducing AUDPC?_  

We would expect to see grain yield decline with increasing AUDPC. Let's just plot yield vs AUDPC.  

```{r Yield_vs_AUDPC}

plot(grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means)
abline(lm(grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means))

```

There appears to be a weak positive relationship between the two continuous variables.  
Does a linear model confirm this?  

```{r AUDPClm}
summary(lm(grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means))
```

This is not what we would expect and the low R squared value of `r round(summary(lm(grain_yield.t.ha. ~ AUDPC_m, data = PM_MB_means))$adj.r.squared,3)` perhaps there are additional factors influencing this relationship.

Lets tease out variation due to trial location, season, row spacing, and other seasonal variables are preventing us from seeing the expected relationship. 
Let's do the plot again for each trial where there are no missing values.  
Note: The plots are ordered by mean yield of the trial.

```{r AUDPCxTrial}
sm2lg <- PM_MB_means %>%
   group_by(trial_ref) %>%
   summarise(TY = mean(grain_yield.t.ha., na.rm = TRUE)) %>%
   arrange(TY)

for (i in sm2lg$trial_ref) {
   dat1 <- PM_MB_means[PM_MB_means$trial_ref == i, ]
   if (any(is.na(dat1$grain_yield.t.ha.))) {
      next
   }
   if (any(is.na(dat1$AUDPC_m))) {
      next
   }
   
   plot(
      grain_yield.t.ha. ~ AUDPC_m,
      data = dat1,
      main = paste(dat1$location[1], (dat1$year[1])),
      ylim = c(0, max(PM_MB_means$grain_yield.t.ha., na.rm = TRUE)),
      xlim = c(0, max(PM_MB_means$AUDPC_m, na.rm = TRUE))
   )
   abline(lm(grain_yield.t.ha. ~ AUDPC_m, data = dat1))
   points(grain_yield.t.ha. ~ AUDPC_m,
          data = dat1[dat1$fungicide_ai == "control",],
          col = "red")
   
}
```

This sequence of graphs show that AUDPC and disease incidence tends not impact on yields if the season is a low yielding, ie lower than 1 tonne per hectare.  
The higher the yield the greater greater the influence on the disease on the yield especially if the crop is high yielding with AUDPC also being large enough to reduce yield.  

Let's have a look again at the same sequence of graphs and analyses for area under the disease progress _stairs_.  

```{r Yield_vs_AUDPS}
plot(grain_yield.t.ha. ~ AUDPS_m, data = PM_MB_means)
abline(lm(grain_yield.t.ha. ~ AUDPS_m, data = PM_MB_means))

summary(lm(grain_yield.t.ha. ~ AUDPS_m, data = PM_MB_means))

sm2lg <- PM_MB_means %>%
   group_by(trial_ref) %>%
   summarise(TY = mean(grain_yield.t.ha., na.rm = TRUE)) %>%
   arrange(TY)



for (i in sm2lg$trial_ref) {
   dat1 <- PM_MB_means[PM_MB_means$trial_ref == i,]
   if (any(is.na(dat1$grain_yield.t.ha.))) {
      next
   }
   if (any(is.na(dat1$AUDPS_m))) {
      next
   }
   
   
   plot(
      grain_yield.t.ha. ~ AUDPS_m,
      data = dat1,
      main = paste(dat1$location[1], (dat1$year[1])),
      ylim = c(0, max(
         PM_MB_means$grain_yield.t.ha., na.rm = TRUE
      )),
      xlim = c(0, max(PM_MB_means$AUDPS_m, na.rm = TRUE))
   )
   abline(lm(grain_yield.t.ha. ~ AUDPS_m, data = dat1))
   points(grain_yield.t.ha. ~ AUDPS_m,
          data = dat1[dat1$fungicide_ai == "control", ],
          col = "red")
   
}

```
The plots from the AUPDS is similar to the AUDPC, however according to the linear model the AUDPC is a better, significant fit.  

A mixed effect model would be more suitable to investigate the interactive effects of location, season, and trial. 
The mixed effect model will help us decide on the best approach and structure for our meta-analysis model.

****

### Disease presure factor
We may wish to investigate the impact of spray management in mitigating the yield loss through the effect on the disease pressure. We will set a categorical variable to indicate the amount of disease pressure in the trial, which will be evaluated on the control plot. 
We will create two categories, `lowD` and `highD`. 
We will use the median `AUDPC` to separate the trials into these two groups.

```{r}
slimmer_PM_dat <- read.csv(here("cache/slimmer_PM_clusterdat.csv"))

slimmer_PM_dat$D_pres <- NA_character_

Trial_Dpress <- slimmer_PM_dat %>%
   group_by(trial_ref) %>%
   filter(fungicide_ai == "control") %>%
   summarise(AUDPC_C = mean(AUDPC_m, na.rm = TRUE))

median_AUDPC <- median(as.vector(Trial_Dpress$AUDPC_C), na.rm = TRUE)   

sort(Trial_Dpress$AUDPC_C)

for(i in unique(slimmer_PM_dat$trial_ref)) {
   if (is.na(Trial_Dpress[Trial_Dpress$trial_ref == i, "AUDPC_C"])) {
      next()
   }
   
   if (Trial_Dpress[Trial_Dpress$trial_ref == i, "AUDPC_C"] < median_AUDPC)
   {
      slimmer_PM_dat[slimmer_PM_dat$trial_ref == i, "D_pres"] <- "lowD"
   } else{
      if (Trial_Dpress[Trial_Dpress$trial_ref == i, "AUDPC_C"] >= median_AUDPC) {
         slimmer_PM_dat[slimmer_PM_dat$trial_ref == i, "D_pres"] <- "highD"
      } else{
         slimmer_PM_dat[slimmer_PM_dat$trial_ref == i, "D_pres"] <-
            NA_character_
      }
      
   }
}

write.csv(slimmer_PM_dat, file = here("cache/slimmer_PM_clusterdat.csv"), row.names = FALSE)
```


Lets have a quick look to examine weather trials with high disease pressure sustain a greater yield loss.  

```{r}
slimmer_PM_dat %>%
   ggplot(aes(x = D_pres, y = grain_yield.t.ha))+
   geom_boxplot()
```

From this plot we see that in the trials with high disease pressure treatments on tended to produce lower yields. 
There are `r length(unique(slimmer_PM_dat[is.na(slimmer_PM_dat$D_pres),"trial_ref"]))` trials that contained no data for AUDPC and thus produced `NA` values.  

```{r delete_this_chunk, eval=FALSE, include=FALSE}
PM_MB_means$infected_days <- as.numeric(PM_MB_means$harvest_date - PM_MB_means$first_sign_disease)

plot(AUDPC_m ~ infected_days, data = PM_MB_means)
plot(grain_yield.t.ha. ~ infected_days, data = PM_MB_means)

PM_MB_means$harvest_date - PM_MB_means$first_sign_disease
```

