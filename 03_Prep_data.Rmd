# Prepare data for meta-analysis

## Set environment and import data

```{r load_libraries, include=FALSE}
if (!require("pacman"))
   install.packages("pacman")
pacman::p_load(tidyverse, kableExtra, agricolae, lme4, here)
if (!require("theme.usq"))
   devtools::install_github("adamhsparks/theme.usq")
library(theme.usq)
theme_set(theme_usq()
)
```

```{r import_data}
load("cache/PreliminaryData.Rdata")
source(here("R/same.R")) # matches each element of a vector and does not return NAs
```

## Subset to Trials containing DMI fungicides

```{r filterDMI_trials}
DMI_Trials <- 
   PM_MB_dat %>%
   filter(fungicide_ai == "tebuconazole" |
             fungicide_ai == "propiconazole")%>%
   distinct(trial_ref) %>%
   pull()

PM_MB_dat <- 
   PM_MB_dat[PM_MB_dat$trial_ref %in% DMI_Trials,]
```

Now remove any non-DMI treatments or controls
```{r}
PM_MB_dat <- 
   PM_MB_dat %>%
   filter(fungicide_ai == "control" |
             fungicide_ai == "tebuconazole" |
             fungicide_ai == "propiconazole")
```


## Standardising sample variance  
Meta-analyses use variance from the data to calculate the effect sizes.
The type of variance needs to be the same across all the data incorporated in the meta-analysis.

We are narrowing the meta-analysis to only include treatments using demethylation inhibitors, tebuconazole and propiconazole.
Let's look at what type of statistical error was reported for the trials that used these fungicides.

```{r variance_types}
PM_MB_dat %>%
   filter(fungicide_ai == "tebuconazole" |
             fungicide_ai == "propiconazole") %>%
   group_by(trial_ref, location, year , Y_error_type) %>%
   summarise(DMI_treatments = length(Y_error_type), .groups = 'drop') %>%
   arrange(Y_error_type) %>%
   kable(caption = "Number of treatments for each trial and the error type reported",
         align = "c") %>%
   footnote(general = "DMI - demethylation inhibitors (tebuconazole and propiconazole).")
```

The experiment summaries report either standard deviation, least square differences. 
First we will convert LSD and standard deviation to sample variance.  


### Converting least-squares to sample variance  

First let's get a list the of trials that reported LSD.  

```{r all_LSD_trials}
Trials <- PM_MB_dat %>%
   filter(Y_error_type == "lsd (P=0.05)") %>%
   select(trial_ref) %>%
   distinct()
Trials
```

Let's use this list of trials to subset the data and calculate sampling variances.  

We will follow the method of converting 'least square differences' (LSD) to sampling variance reported by [Nugugi et.al (2011)](https://apsjournals.apsnet.org/doi/10.1094/PHYTO-08-10-0221).  

```{r LSD_2_Sampling_Variance}
Tcrit <- 2.042 

for (i in Trials$trial_ref) {
   DFw <-
      sum(PM_MB_dat[PM_MB_dat$trial_ref == i, ]$replicates) -
      length(PM_MB_dat[PM_MB_dat$trial_ref == i, ]$replicates) # degrees of freedom within groups
   
   LSD <-
      PM_MB_dat[PM_MB_dat$trial_ref == i, ]$yield_error[1]
   
   
   V_yield <-
      (PM_MB_dat[PM_MB_dat$trial_ref == i, ]$replicates[1] * 
          (LSD / Tcrit) ^ 2) / 2 
   # method - Nugugi et.al (2011) DOI: 10.1094/phyto-08-10-0221

   for (j in seq_along(PM_MB_dat[PM_MB_dat$trial_ref == i,]$replicates)) {
      if (j == 1) {
         Sv <-
            vector(length = length(PM_MB_dat[PM_MB_dat$trial_ref == i,]$replicates))
      } # reset Sv vector if this is the first loop
      
      
      Sv[j] = V_yield /
         PM_MB_dat[PM_MB_dat$trial_ref == i,]$replicates[j]
      
   }
   
   # Replace the values in the dataset
   PM_MB_dat[PM_MB_dat$trial_ref == i,]$yield_error <-
      Sv
   PM_MB_dat[PM_MB_dat$trial_ref == i,]$Y_error_type <-
      "SamplingVariance"
}
```

### Converting standard deviation to sample variance

Now to estimate the variance from the standard deviation.

```{r stdev2SampVariance}
# subset data by those which describe the Yield error with standard deviation
Trials <- PM_MB_dat %>%
   filter(Y_error_type == "stdev") %>%
   select(trial_ref) %>%
   pull()

PM_MB_dat[PM_MB_dat$trial_ref %in% Trials,"yield_error"] <- 
   PM_MB_dat[PM_MB_dat$trial_ref %in% Trials,"yield_error"]^2

PM_MB_dat[PM_MB_dat$trial_ref %in% Trials,]$Y_error_type <-
   "SamplingVariance"

```


### Check variance of data-set
Our data currently uses sample variance to define the yield error.
We should expect that when yield increases so does the variance.
Let's quickly plot this to check.

```{r Var_mean_sqaures}
PM_MB_dat %>%
   ggplot(aes(x = grain_yield.t.ha., y = yield_error)) +
   geom_point()
```
No association between yield and sample variance, this might be due to the unpredictable nature of mungbeans.

Lets look at the association between mean squares and yield to see if there is a more typical association between yield and variance.

```{r Var_MeanSquarePlot}
PM_MB_dat %>%
   ggplot(aes(x = grain_yield.t.ha., y = Y_Msquare/replicates)) +
   geom_point()
PM_MB_dat[is.na(PM_MB_dat$Y_Msquare),]

```

## Classifying fungicide treatment  

First we need to calculate the time between the first sign of disease and the fungicide treatments.  

```{r clustered_fungicide_applications}
PM_MB_dat %<>%
   mutate(fungicide_timing_1 = fungicide_application_1 - first_sign_disease) %>%
   mutate(fungicide_timing_2 = fungicide_application_2 - fungicide_application_1) %>%
   mutate(fungicide_timing_3 = fungicide_application_3 - fungicide_application_2)
   
```

To ensure sufficient number of replicates, we will bin the continuous variable into three categorical variables relating to when the first fungicide application was made.  

These categorical variables are named:

   - **Early**: First fungicide application was prior to first sign of disease.  

   - **Recommended**: First fungicide application was applied on the day powdery mildew was observed, or within three days of first sign.  

   - **Late**: First fungicide application was four or more days after first sign of disease being observed.  
   
The number of sprays need also be defined.

```{r}
data.frame(TreatmentName = c("Early", "Recommended", "Late", "EarlyPlus", "RecommendedPlus", "LatePlus"),
           n_sprays = rep(c("Single", "Two - Three"), each = 3),
           DaysRelativeToFirstSign = c("Prior to first sign of Powdery Mildew",
                                       "1 - 3 days after first sign of Powdery Mildew",
                                       "7 - 8 days after first sign of Powdery Mildew"))%>%
   kable()
```


```{r simple_clusters}
PM_MB_dat <- PM_MB_dat %>%
   mutate(
      spray_management = case_when(
         fungicide_timing_1 < 0 &
            is.na(fungicide_application_2) &
            is.na(fungicide_application_3) ~ "Early",
         fungicide_timing_1 >= 0 &
            fungicide_timing_1 < 4 &
            is.na(fungicide_application_2) &
            is.na(fungicide_application_3) ~ "Recommended",
         fungicide_timing_1 >= 4 &
            is.na(fungicide_application_2) &
            is.na(fungicide_application_3) ~ "Late",
         fungicide_timing_1 < 0 &
            !is.na(fungicide_application_2) ~ "Early_plus",
         fungicide_timing_1 >= 0 &
            fungicide_timing_1 < 4 &
            !is.na(fungicide_application_2) ~ "Recommended_plus",
         fungicide_timing_1 >= 4 &
            !is.na(fungicide_application_2) ~ "Late_plus",
         TRUE ~ "Other"
      )
   )

PM_MB_dat[PM_MB_dat$fungicide_ai == "control",
            c(
               "fungicide_timing_1",
               "fungicide_timing_2",
               "fungicide_timing_3",
               "spray_management"
            )] <- "control"
```

Now to view the number break-down of the `spray_management` treatments

```{r tableSprayManagement}
table(PM_MB_dat$spray_management)
```

There are few 'Early_plus' treatments, these treatments therefore will have too few comparisons with other treatments in the meta-analysis to provide accurate results. Therefore we will remove 'Early_plus' from the analysis.

```{r simpler_clusters_remove}
PM_MB_dat <-
   PM_MB_dat %>%
   filter(spray_management != "Early_plus")
```

****

## Trial factor
We have a number of variable which could introduce variation in our analysis. 
We will combine these variables into a single variable called `trial` which will help us define the between trial variation.  

```{r define_trial}
PM_MB_dat <-
   PM_MB_dat %>%
   mutate(trial = paste(trial_ref, year, location, host_genotype,
                        row_spacing, sep = "_")) %>%
   select(trial_ref, trial, everything())
```


## Test dose effect

Earlier we noted there were different doses of propiconazole, which might influence our analysis.
Let's add the dose variable to the `trial` variable then compare linear mixed effect models including and excluding dose in the trial variable.
We already have a factor breaking down the dose in the `trial` variable.
Let's make a new one without dose.

```{r define_Dose}
table(PM_MB_dat$dose_ai.ha)

PM_MB_dat <- 
   PM_MB_dat %>%
   mutate(dose = case_when(
      dose_ai.ha == 0 ~ "control",
      dose_ai.ha <= 70 ~ "lowDose",
      dose_ai.ha > 70 ~ "highDose",
      TRUE ~ NA_character_
   ))

```


```{r dose_test}
PM_MB_dat <-
   PM_MB_dat %>%
    mutate(trial_dose = paste(trial_ref, year, location, host_genotype,
                        row_spacing,dose , sep = "_"))
   
cbind(NoDose = head(PM_MB_dat$trial),
      Dose = head(PM_MB_dat$trial_dose)) %>%
   kable()
```

Let's test the dose effect in a basic linear mixed effect model.

```{r dose_lmer}
m_noDose <-
   lmer(log(grain_yield.t.ha. * 1000) ~ factor(spray_management) +
           (1 | trial),
        data = PM_MB_dat)

m_dose <-
   lmer(log(grain_yield.t.ha. * 1000) ~ factor(spray_management) +
           (1 | trial_dose),
        data = PM_MB_dat)

anova(m_noDose, m_dose)
```

Using the model without dose produces a lower AIC and we find no significant difference between models.
We will not use dose as a defining variable in `trial`.  

Remove columns which are not needed
```{r saveDat}
PM_MB_dat <-
   PM_MB_dat %>%
   select(-c(trial_dose,fungicide_timing_1,fungicide_timing_2, fungicide_timing_3, 
             dose, fungicide_application_4, fungicide_application_5, fungicide_application_6,
             fungicide_application_7)) 
```


## Row spacing

We may want to consider row spacing in the trials.
However one of the locations has `NA` as the row spacing.
```{r}
PM_MB_dat%>%
   filter(is.na(row_spacing))%>%
   select(trial_ref,year, location, row_spacing,spray_management,host_genotype, fungicide_ai)
```

For now let's assign the most used row spacing of 0.33 m as an approximation so the model can analyse this as a continuous variable. 
If we decide to use the row_spacing column as a factor in the final model we will need to remove this approximation.  

```{r assign_row_spacing_missing}
PM_MB_dat[is.na(PM_MB_dat$row_spacing),"row_spacing"] <- 0.33
```

# Perhaps move below to post analysis, analysis

### Mungbeans age and yield saved

The time at which powdery mildew infects in the seasons and the age of the plant might affect the AUDPC and the loss in yield.
Let's have a look at the age of each trial when powdery mildew infected it.
We will use the difference between `planting_date` and `first_sign_disease` as a proxy for crop maturity when it became infected.

```{r age_andYield}
dat1 <- PM_MB_dat %>%
   mutate(days2PM = first_sign_disease - planting_date) %>%
   arrange(desc(days2PM)) %>%
   select(
      trial_ref,
      year,
      location,
      spray_management,
      days2PM,
      grain_yield.t.ha,
      yield_gain,
      prop_yield_gain,
      AUDPC_m,
      D_pres,
      PM_final_severity
   )
dat1
```

From these trials I am most interested in the experiments that directly compare `Recommended` with `Recommended_P_plus` and/or `Late` with `Late_plus`. 
Therefore I will not inspect, `AM1304` (Marys Mount), which only trialled an early, prophylactic spray.  

We can see that the crops which were likely the most mature, did not show large yield gains, in particular:

   * Hermitage 2019  
   * Premer  
   * Goolhi  
   * Millmerran  

Let's look at this in a quick box plot. 
We will only look at trials where powdery mildew set in 60 days after planting, when the physiological maturity was likely flowering.

```{r ageBoxPlot}
dat1 %>%
   filter(days2PM >= 60) %>%
   filter(spray_management != "control" &
             trial_ref != "AM1304") %>%
   group_by(trial_ref, spray_management) %>%
   ggplot(aes(x = spray_management, y = yield_gain, colour = trial_ref)) +
   geom_boxplot() +
   scale_fill_usq() +
   geom_hline(yintercept = 0)
```

We can see in these experiments five experiments there is clearly no benefit to applying a second fungicide application given the values of the recommended _plus treatment were predominantly lower than zero. 

For completeness let's test this with powdery mildew infection commencing 40 - 60 days after planting, instead of greater than 60.  

```{r PM40_2_59_days}
dat1 %>%
   filter(days2PM < 60 &
             days2PM >= 40) %>%
   filter(spray_management != "control") %>%
   group_by(trial_ref, spray_management) %>%
   ggplot(aes(x = spray_management, y = yield_gain, colour = trial_ref)) +
   geom_boxplot() +
   scale_fill_usq() +
   geom_hline(yintercept = 0)
```

We can see here all four experiments benefited, on average, from more than one spray.  

Let's estimate the age of the crop based on crop maturity observations, we will use the `PM_MB_dat` which include some observations of crop maturity.

```{r whatAreTheAges}
dat2 <- PM_MB_dat %>%
   mutate(
      flower = lubridate::ymd(flowering_date) - lubridate::ymd(planting_date),
      pod = lubridate::ymd(pod_fill_date) - lubridate::ymd(planting_date),
      late_pod = lubridate::ymd(mid_late_pod_fill) - lubridate::ymd(planting_date)
   ) %>%
   select(location, year, flower, pod, late_pod) %>%
   distinct() %>%
   arrange(desc(flower))

index1 <-
   apply(dat2, 1 , function(X)
      ! all(is.na(X[c("flower", "pod", "late_pod")])))

dat2[index1,]
as.double(mean(dat2[index1, "flower"], na.rm = TRUE))
as.double(mean(dat2[index1, "pod"], na.rm = TRUE))
as.double(mean(dat2[index1, "late_pod"], na.rm = TRUE))
```

We can see that flowering and podding can be variable, and depend on the cumulative degree days.
However, on average flowering starts `r as.double(mean(dat2[index1,"flower"], na.rm = TRUE))` days after sowing, podding starts `r as.double(mean(dat2[index1,"pod"], na.rm = TRUE))`, and late podding `r as.double(mean(dat2[index1,"late_pod"], na.rm = TRUE))`.
