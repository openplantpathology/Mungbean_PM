# Place holder



```{r load_libraries}
library(dplyr)
library(readr)
```

```{r import_data}
source("R/import_data.R")
PM_MB_means <- import_data()
```


## Standardising sample variance  

The type of variance needs to be standardised between trials and treatments for the meta-analysis. 

```{r variance_types}
# PM_MB_means$Y_error_type <- forcats::fct_explicit_na(PM_MB_means$Y_error_type, na_level = NA)
# Trials using tebuconazole
PM_MB_means %>%
   filter(fungicide_ai == "tebuconazole",
         row_spacing == 0.75) %>%
   group_by(trial_ref, location, Y_error_type) %>%
   summarise(tebuconazole_trts = length(Y_error_type))


# Trials using propiconazole
PM_MB_means %>%
   filter(fungicide_ai == "propiconazole",
          row_spacing == 0.75) %>%
   group_by(trial_ref, location, Y_error_type) %>%
   summarise(propiconazole_trts = length(Y_error_type))
```

The experiment summaries report either standard deviation, least square differences or no error term (`NA`). Below we will convert LSD and standard deviation to sample variance

### Converting least-squares to sample variance

```{r all_LSD_trials}
Trials <- PM_MB_means %>%
   filter(
          Y_error_type == "lsd (P=0.05)") %>%
   select(trial_ref) %>%
   distinct()
Trials
```


The trial, `mung1112/02` uses Least Square Differences (LSD) to describe the variation within the experiment.
The following code attempts to convert this to sampling variance as per the method in [Nugugi et.al (2011)](https://apsjournals.apsnet.org/doi/10.1094/PHYTO-08-10-0221).
Ideas for using a T-critical value of 1.697 came from reading a [statisics-how-to website](https://www.statisticshowto.datasciencecentral.com/how-to-calculate-the-least-significant-difference-lsd/).
A [table of T-critical values](https://www.statisticshowto.datasciencecentral.com/tables/t-distribution-table/) was consulted where 30 degrees of freedom within experiment was used to find the 'T-crit' value of 1.697.

![Calculating sampling variance from mean squared error Paul et al. (2008)](Paul_etal_2008.PNG)

```{r LSD_2_Sampling Variance}
# Formula and modifications based off information found at https://www.statisticshowto.datasciencecentral.com/how-to-calculate-the-least-significant-difference-lsd/

for (Trial2012 in Trials$trial_ref) {
   Tcrit <-
      1.697  # 0.05 and DFw = 30 # T critical value for which there is significant difference between two groups; This value is the same for both trials "mung1112/01" and "mung1112/02"
   DFw <-
      sum(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) -
      length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) # degrees of freedom within groups
   # n.A <- PM_MB_means[PM_MB_means$trial_ref == "Trial2012,]$replicates[1]
   # n.B <- PM_MB_means[PM_MB_means$trial_ref == "Trial2012,]$replicates[2]
   LSD <-
      PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error[1]
   
   
   # SSwithin <- #unknown
   # MSW <- SSwithin / DFw # mean square within (SS within / DF within)
   
   
   #  LSD = (Tcrit) * sqrt(MSW * (1/n.A + 1/n.B))
   #  (LSD/Tcrit) = sqrt(MSW * (1/n.A + 1/n.B))
   #  (LSD/Tcrit)^2 = MSW * (1/n.A + 1/n.B)
   #  (LSD/Tcrit)^2/(1/n.A + 1/n.B) = MSW
   #  MSE <- (LSD/Tcrit)^2/(1/n.A + 1/n.B) # This formula was abandon in favor for the formula in Nugugi et. at (2011)
   MSE <-
      PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[1] * (LSD /
                                                                            Tcrit) ^ 2 / 2 # method for finding variance in Nugugi et.al (2011) DOI: 10.1094/phyto-08-10-0221
   
   
   for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates)) {
      if (j == 1) {
         Sv <-
            vector(length = length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates))
      }
      #  Sv[j]^2 = MSE/(PM_MB_means[PM_MB_means$trial_ref == Trial2012,]$replicates[j] *
      #                   PM_MB_means[PM_MB_means$trial_ref == Trial2012,]$grain_yield.t.ha[j])
      # Balance equation
      Sv[j] = sqrt(MSE / (
         PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[j] *
            as.numeric(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$grain_yield.t.ha[j])
      ))
      
   }
   
   # and replacing the values in the dataset
   
   PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error <-
      Sv
   PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$Y_error_type <-
      "SamplingVariance"
   
}
```


### Converting standard deviation to sample variance
Now to estimate the variance from the standard deviation

```{r stdev2SampVariance}
# subset data by those which describe the Yield error with standard deviation
Trials <- PM_MB_means %>%
   filter(#fungicide_ai == "tebuconazole",
      #row_spacing.m == 0.75,
      Y_error_type == "stdev") %>%
   select(trial_ref) %>%
   distinct()


# calculate the Sampling variance from the standard deviation
# standard error of the mean equals the standard deviation divided by the square root of the number of samples
# Sv <- sem^2 <- stdev/sqrt(n)
# Sampling variance equals the square of the standard error.
# Sv <- (stdev/sqrt(n))^2

# Therefore

for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error)) {
   # create empty vector at first iteration with length of j
   if (j == 1) {
      Sv <-
         vector(length = length(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error))
   }
   
   # Equation to convert standard deviation to Sampling Variance
   Sv[j] = (PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error[j]) ^
      2
}

# and replacing the values in the dataset
PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error <-
   Sv
PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$Y_error_type <-
   "SamplingVariance"
```


## Yield gains  
Yield gains and yield gains proportional to the control.

Data from `r length(PM_MB_means$trial_ref)` trials were collected and the means of each treatment calculated (`R/Cleaning historical data.R`). These data were combined into one file `1902 powdery mildew-Mungbean - Collated means.csv`.

```{r Calculate_yield-gains}
PM_MB_means$grain_yield.t.ha. <-
   as.numeric(PM_MB_means$grain_yield.t.ha.) # NAs produced due to some cells having text description to why there is no specific data

for (i in unique(PM_MB_means$trial_ref)) {
   dat1 <- PM_MB_means[PM_MB_means$trial_ref == i, ]
   
   if (any(is.na(unique(dat1$row_spacing)))) {
      warning(
         paste(
            unique(dat1$trial_ref),
            "at",
            unique(dat1$location),
            "in year",
            unique(dat1$year),
            "has unknown row.spacing (NA)\n 'yield_gain' and 'proportional yield gain' not calculated\n"
         )
      )
      next()
   }
   
   for (j in unique(dat1$row_spacing)) {
      dat2 <- dat1[dat1$row_spacing == j, ]
      controlY <-
         mean(dat2[dat2$fungicide == "control", "grain_yield.t.ha."])
      
      dat2$yield_gain <- dat2$grain_yield.t.ha. - controlY
      dat2$prop_YG <- dat2$yield_gain  /  controlY
      
      dat2[dat2$fungicide == "control", c("yield_gain", "prop_YG")] <-
         NA
      
      dat1[dat1$row_spacing == j, ] <- dat2
   }
   PM_MB_means[PM_MB_means$trial_ref == i, ] <- dat1
}



# ____________________________________________
# calculate yield gain and prop_yield gain for experiments with no row spacing data

dat1 <- PM_MB_means[PM_MB_means$trial_ref == "AM1303", ]

controlY <-
   mean(dat1[dat1$fungicide == "control", "grain_yield.t.ha."])

dat1$yield_gain <- dat1$grain_yield.t.ha. - controlY
dat1$prop_YG <- dat1$yield_gain / controlY
dat1[dat1$fungicide == "control", c("yield_gain", "prop_YG")] <- NA
PM_MB_means[PM_MB_means$trial_ref == "AM1303", ] <- dat1

write.csv(PM_MB_means,
          "data/1911_PM_MB_means&Ygains.csv")
```




```{r clustered_fungicide_applications}
source("R/slimming_PM_dat.R")
head(slim_PM_dat)


slim_PM_dat %<>%
  mutate(fungicide_timing_1 = fungicide_application_1 - first_sign_disease) %>%
  mutate(fungicide_timing_2 = fungicide_application_2 - fungicide_application_1) %>%
  mutate(fungicide_timing_3 = fungicide_application_3 - fungicide_application_2) %>%
  filter(!is.na(grain_yield.t.ha)) %>% 
  filter(!is.na(PM_final_severity))


```


```{r cluster}

slim_PM_dat %<>%
  mutate(
    cluster_1 = case_when(
      fungicide_timing_1 < 0 ~ "Early",
      fungicide_timing_1 >= 0 &
        fungicide_timing_1 < 4 ~ "Recommended",
      TRUE ~ "Late"
    )
  ) %>%
  mutate(
    cluster_2 = case_when(
      is.na(fungicide_timing_2) ~ NA_character_,
      fungicide_timing_2 < 13 ~ "Early",
      fungicide_timing_2 >= 13 &
        fungicide_timing_2 < 17 ~ "Recommended",
      TRUE ~ "Late"
    )
  ) %>% 
  mutate(
    cluster_3 = case_when(
      fungicide_timing_3 < 14 ~ "Early",
      is.na(fungicide_timing_3) ~ NA_character_,
      TRUE ~ "Recommended"
    )
  )

slim_PM_dat[slim_PM_dat$fungicide_ai == "control",
            c("fungicide_timing_1", "fungicide_timing_2", "fungicide_timing_3",
              "cluster_1", "cluster_2","cluster_3"
              )] <- "control"

write.csv(slim_PM_dat, file = "data/slim_PM_clusterdat.csv", row.names = FALSE)

```

Cluster the clusters

```{r cluster_clusters}

clusters <- unique(slim_PM_dat[c("cluster_1","cluster_2","cluster_3")])

for(i in 1:nrow(clusters)){
   if(i == 1){clusters$n <- NA
   clusters$n_x_trial <- NA}
   
   clusters[i,"n"] <- nrow(slim_PM_dat[slim_PM_dat$cluster_1 == clusters[i,"cluster_1"] &
                                          slim_PM_dat$cluster_2 == clusters[i,"cluster_2"] &
                                          slim_PM_dat$cluster_3 == clusters[i,"cluster_3"],
                                       ])
   
   clusters[i,"n_x_trial"] <- length(unique(slim_PM_dat[slim_PM_dat$cluster_1 == clusters[i,"cluster_1"] &
                                          slim_PM_dat$cluster_2 == clusters[i,"cluster_2"] &
                                          slim_PM_dat$cluster_3 == clusters[i,"cluster_3"],
                                       "trial_ref"]))
   
}

knitr::kable(clusters)

```

From this we can see that there are 16 different cluster combinations, which would make the analysis too difficult. I will reduce this to 6 levels within one variable.  

Single sprays either early, recommended timing or late.

Two sprays or more where the first spray was either early, recommended timing, or late.


```{r simple_clusters}

slim_PM_dat <- slim_PM_dat %>%
   mutate(
    spray_management = case_when(
       fungicide_timing_1 < 0 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Early",
       fungicide_timing_1 >= 0 &
          fungicide_timing_1 < 4 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Recommended",
      fungicide_timing_1 >= 4 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Late",
      fungicide_timing_1 < 0 &
          !is.na(fungicide_application_2) ~ "Early_plus",
       fungicide_timing_1 >= 0 &
          fungicide_timing_1 < 4 &
          !is.na(fungicide_application_2) ~ "Recommended_plus",
      fungicide_timing_1 >= 4 ~ "Late_plus",
      TRUE ~ "Other"
    )
  ) 

slim_PM_dat[slim_PM_dat$fungicide_ai == "control",
            c("fungicide_timing_1", "fungicide_timing_2", "fungicide_timing_3",
              "spray_management"
              )] <- "control"

table(slim_PM_dat$spray_management)
sum(table(slim_PM_dat$spray_management)[1:7])
nrow(slim_PM_dat)

write.csv(slim_PM_dat, file = "data/slim_PM_clusterdat.csv", row.names = FALSE)
```




```{r simpler_clusters_REMOVE}

slim_PM_dat <- slim_PM_dat %>%
   mutate(
    spray_management = case_when(
       fungicide_timing_1 < 0 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Early",
       fungicide_timing_1 >= 0 &
          fungicide_timing_1 < 4 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Recommended",
      fungicide_timing_1 >= 4 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Late",
      fungicide_timing_1 < 0 &
          !is.na(fungicide_application_2) ~ "Early_plus",
       fungicide_timing_1 >= 0 &
          fungicide_timing_1 < 4 &
          !is.na(fungicide_application_2) ~ "Recommended_plus",
      fungicide_timing_1 >= 4 ~ "Late_plus",
      TRUE ~ "Other"
    )
  ) 

slim_PM_dat[slim_PM_dat$fungicide_ai == "control",
            c("fungicide_timing_1", "fungicide_timing_2", "fungicide_timing_3",
              "spray_management"
              )] <- "control"

table(slim_PM_dat$spray_management)

# Remove "Early_plus" and "Late" due to lack of replicates

slimmer_PM_dat <- slim_PM_dat[slim_PM_dat$spray_management != "Late" & 
               slim_PM_dat$spray_management != "Early_plus",]

write.csv(slimmer_PM_dat, file = "data/slimmer_PM_clusterdat.csv", row.names = FALSE)
```


```{r Trial_variance}

slimmer_PM_dat$SSquare <- 
   slimmer_PM_dat$yield_error * (slimmer_PM_dat$n - 1)

slimmer_PM_dat$pop_var <- NA

for(i in unique(slimmer_PM_dat$trial)){
   pop_var <- sqrt(
      sum(slimmer_PM_dat[slimmer_PM_dat$trial == i,"SSquare"])/
         sum(slimmer_PM_dat[slimmer_PM_dat$trial == i,"n"])
      )
      
slimmer_PM_dat[slimmer_PM_dat$trial == i, "pop_var"] <- pop_var
   
}


write.csv(slimmer_PM_dat, file = "data/slimmer_PM_clusterdat.csv", row.names = FALSE)

```




