## Set environment and import data  

```{r load_libraries}
library(dplyr)
library(readr)
library(kableExtra)
library(ggplot2)
```

```{r import_data}
source("R/import_data.R")
PM_MB_means <- import_data()

```


## Standardising sample variance  
Meta-analyses use variance from the data to calculate the effect sizes. The type of variance needs to be the same across all the data incorporated in the meta-analysis.  

We are narrowing the meta-analysis to only include demethylation inhibitors, tebuconazole and propiconazole. Within studies which have used these fungicides, what type of error was reported?  

```{r variance_types}
PM_MB_means %>%
   filter(fungicide_ai == "tebuconazole" |
             fungicide_ai == "propiconazole",
         row_spacing == 0.75) %>%
   group_by(trial_ref, location, Y_error_type, fungicide_ai) %>%
   summarise(DMI_trts = length(Y_error_type))%>%
   arrange(Y_error_type)%>%
   kable(caption = "Number of treatments for each trial and the error type reported") %>%
   kable_styling(fixed_thead = T) %>%
   footnote(general = "DMI - demethylation inhibitors (tebuconazole and propiconazole).")


```

The experiment summaries report either standard deviation, least square differences or no error term (`NA`). Below we will convert LSD and standard deviation to sample variance. In addition, we need to impute variances for the trials which did not report any form of variance (`NA`).  



### Converting least-squares to sample variance

```{r all_LSD_trials}
Trials <- PM_MB_means %>%
   filter(
          Y_error_type == "lsd (P=0.05)") %>%
   select(trial_ref) %>%
   distinct()
```


The following code attempts to convert 'least square differences' (LSD) to sampling variance as per the method in [Nugugi et.al (2011)](https://apsjournals.apsnet.org/doi/10.1094/PHYTO-08-10-0221).
Ideas for using a T-critical value of 1.697 came from reading a [statisics-how-to website](https://www.statisticshowto.datasciencecentral.com/how-to-calculate-the-least-significant-difference-lsd/).
A [table of T-critical values](https://www.statisticshowto.datasciencecentral.com/tables/t-distribution-table/) was consulted where 30 degrees of freedom within experiment was used to find the 'T-crit' value of 1.697.  

![Calculating sampling variance from mean squared error Paul et al. (2008)](Paul_etal_2008.PNG)  

```{r LSD_2_Sampling Variance}

for (Trial2012 in Trials$trial_ref) {
   Tcrit <-
      1.697  # 0.05 and DFw = 30 # T critical value for which there is significant difference between two groups; This value is the same for both trials "mung1112/01" and "mung1112/02"
   DFw <-
      sum(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) -
      length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates) # degrees of freedom within groups

   LSD <-
      PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error[1]
   
   
   V_yield <-
      (PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[1] * (LSD /
                                                                            Tcrit) ^ 2) / 2 # method - Nugugi et.al (2011) DOI: 10.1094/phyto-08-10-0221
   
   
   for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates)) {
      if (j == 1) {
         Sv <-
            vector(length = length(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates))
      } # reset Sv vector if this is the first loop
      
      
      
      
      ###############################################3
      # ___ Adjusting formula to suit our data_______
      #
      #  Sv[j]^2 = MSE/(PM_MB_means[PM_MB_means$trial_ref == Trial2012,]$replicates[j] *
      #                   PM_MB_means[PM_MB_means$trial_ref == Trial2012,]$grain_yield.t.ha[j])
      # Balance equation
      # Sv[j] = V_yield / 
      #    (PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[j] *
      #       as.numeric(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$grain_yield.t.ha[j])^2)
      # #################################################################
      
      
      
      
      Sv[j] = V_yield / 
         PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[j]
      
      # Sv[j] = MSE / 
      #    (PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$replicates[j] *
      #       as.numeric(PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$grain_yield.t.ha[j])^2)
      # 
      
      ### -> This formula should be V = (n * (LSD/1.96)^2) / 2
      
   }
   
   # and replacing the values in the dataset
   
   PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$yield_error <-
      Sv
   PM_MB_means[PM_MB_means$trial_ref == Trial2012, ]$Y_error_type <-
      "SamplingVariance"
   
}
```


### Converting standard deviation to sample variance
Now to estimate the variance from the standard deviation

```{r stdev2SampVariance}
# subset data by those which describe the Yield error with standard deviation
Trials <- PM_MB_means %>%
   filter(Y_error_type == "stdev") %>%
   select(trial_ref) %>%
   distinct()


# calculate the Sampling variance from the standard deviation
# standard error of the mean equals the standard deviation divided by the square root of the number of samples
# Sv <- sem^2 <- stdev/sqrt(n)
# Sampling variance equals the square of the standard error.
# Sv <- (stdev/sqrt(n))^2

# Therefore

for (j in seq_along(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error)) {
   if (j == 1) {
      Sv <-
         vector(length = length(PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error))
   }# create empty vector at first iteration with length of j
   
   Sv[j] = (PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error[j]) ^
      2
}

# and replacing the values in the dataset
PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$yield_error <-
   Sv
PM_MB_means[PM_MB_means$trial_ref %in% Trials$trial_ref,]$Y_error_type <-
   "SamplingVariance"

```


## Yield saving  
Yield saving and Yield saving proportional to the control.  

Data from `r length(PM_MB_means$trial_ref)` trials were collected and the means of each treatment calculated (`R/Cleaning historical data.R`). These data were combined into one file `1902 powdery mildew-Mungbean - Collated means.csv`.

```{r Calculate_yield-gains}
PM_MB_means$grain_yield.t.ha. <-
   as.numeric(PM_MB_means$grain_yield.t.ha.) # NAs produced due to some cells having text description to why there is no specific data

for (i in unique(PM_MB_means$trial_ref)) {
   dat1 <- PM_MB_means[PM_MB_means$trial_ref == i, ]
   
   if (any(is.na(unique(dat1$row_spacing)))) {
      warning(
         paste(
            unique(dat1$trial_ref),
            "at",
            unique(dat1$location),
            "in year",
            unique(dat1$year),
            "has unknown row.spacing (NA)\n 'yield_gain' and 'proportional yield gain' not calculated\n"
         )
      )
      next()
   }
   
   for (j in unique(dat1$row_spacing)) {
      dat2 <- dat1[dat1$row_spacing == j, ]
      controlY <-
         mean(dat2[dat2$fungicide_ai == "control", "grain_yield.t.ha."])
      
      dat2$yield_gain <- dat2$grain_yield.t.ha. - controlY
      dat2$prop_YG <- dat2$yield_gain  /  controlY
      
      dat2[dat2$fungicide_ai == "control", c("yield_gain", "prop_YG")] <-
         NA
      
      dat1[dat1$row_spacing == j, ] <- dat2
   }
   PM_MB_means[PM_MB_means$trial_ref == i, ] <- dat1
}



# ____________________________________________
# calculate yield gain and prop_yield gain for experiments with no row spacing data

dat1 <- PM_MB_means[PM_MB_means$trial_ref == "AM1303", ]

controlY <-
   mean(dat1[dat1$fungicide == "control", "grain_yield.t.ha."])

dat1$yield_gain <- dat1$grain_yield.t.ha. - controlY
dat1$prop_YG <- dat1$yield_gain / controlY
dat1[dat1$fungicide == "control", c("yield_gain", "prop_YG")] <- NA
PM_MB_means[PM_MB_means$trial_ref == "AM1303", ] <- dat1

write.csv(PM_MB_means,
          "data/1911_PM_MB_means&Ygains.csv")
```

## Reduce data set to required variables  
Lets tidy up the data set into a data frame of only the variables which are required for the analysis.  

First remove the irrelevant columns/variables. Then calculate fungicide application timing variables relative to the first sign of disease. Entries with NA in the grain yield or powdery mildew severity are also removed from the data.    

```{r clustered_fungicide_applications}
source("R/slimming_PM_dat.R") # see R script for the code which reduces the data.

slim_PM_dat %<>%
  mutate(fungicide_timing_1 = fungicide_application_1 - first_sign_disease) %>%
  mutate(fungicide_timing_2 = fungicide_application_2 - fungicide_application_1) %>%
  mutate(fungicide_timing_3 = fungicide_application_3 - fungicide_application_2) %>%
  filter(!is.na(grain_yield.t.ha)) %>% 
  filter(!is.na(PM_final_severity))

head(slim_PM_dat)
```

### Cluster fungicide applications  
We are going to define 'fungicide application timing' as a categorical variable, relative to the first sign of powdery mildew.  

These categorical variables are named:  
   - **Early**: First fungicide application was prior to first sign of disease.  
   - **Recommended**: First fungicide application was applied on the day powdery mildew was observed, or within three days of first sign.  
   - **Late**: First fungicide application was four or more days after first sign of disease being observed.  

Follow up fungicide applications (cluster_2 and cluster_3) were also categorised as either, early, recommended or late.  

```{r cluster}

slim_PM_dat %<>%
  mutate(
    cluster_1 = case_when(
      fungicide_timing_1 < 0 ~ "Early",
      fungicide_timing_1 >= 0 &
        fungicide_timing_1 < 4 ~ "Recommended",
      TRUE ~ "Late"
    )
  ) %>%
  mutate(
    cluster_2 = case_when(
      is.na(fungicide_timing_2) ~ NA_character_,
      fungicide_timing_2 < 13 ~ "Early",
      fungicide_timing_2 >= 13 &
        fungicide_timing_2 < 17 ~ "Recommended",
      TRUE ~ "Late"
    )
  ) %>% 
  mutate(
    cluster_3 = case_when(
      fungicide_timing_3 < 14 ~ "Early",
      is.na(fungicide_timing_3) ~ NA_character_,
      TRUE ~ "Recommended"
    )
  )



```

Lets look at these clusters to see where we have the most degrees of freedom.  

```{r cluster_clusters}

clusters <- unique(slim_PM_dat[c("cluster_1","cluster_2","cluster_3")])

for(i in 1:nrow(clusters)){
   if(i == 1){clusters$n <- NA
   clusters$n_x_trial <- NA}
   
   clusters[i,"n"] <- nrow(slim_PM_dat[slim_PM_dat$cluster_1 == clusters[i,"cluster_1"] &
                                          slim_PM_dat$cluster_2 == clusters[i,"cluster_2"] &
                                          slim_PM_dat$cluster_3 == clusters[i,"cluster_3"],
                                       ])
   
   clusters[i,"n_x_trial"] <- length(unique(slim_PM_dat[slim_PM_dat$cluster_1 == clusters[i,"cluster_1"] &
                                          slim_PM_dat$cluster_2 == clusters[i,"cluster_2"] &
                                          slim_PM_dat$cluster_3 == clusters[i,"cluster_3"],
                                       "trial_ref"]))
   
}

knitr::kable(clusters)

```

From this we can see that there are 16 different cluster combinations, which would make the analysis too difficult. I will reduce this to 6 levels within one variable.  

Single sprays either early, recommended timing or late.

Two sprays or more where the first spray was either early, recommended timing, or late.


```{r simple_clusters}

slim_PM_dat <- slim_PM_dat %>%
   mutate(
    spray_management = case_when(
       fungicide_timing_1 < 0 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Early",
       fungicide_timing_1 >= 0 &
          fungicide_timing_1 < 4 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Recommended",
      fungicide_timing_1 >= 4 &
          is.na(fungicide_application_2) &
          is.na(fungicide_application_3) ~ "Late",
      fungicide_timing_1 < 0 &
          !is.na(fungicide_application_2) ~ "Early_plus",
       fungicide_timing_1 >= 0 &
          fungicide_timing_1 < 4 &
          !is.na(fungicide_application_2) ~ "Recommended_plus",
      fungicide_timing_1 >= 4 ~ "Late_plus",
      TRUE ~ "Other"
    )
  ) 

slim_PM_dat[slim_PM_dat$fungicide_ai == "control",
            c("fungicide_timing_1", "fungicide_timing_2", "fungicide_timing_3",
              "spray_management"
              )] <- "control"


table(slim_PM_dat$spray_management)

```
There are few 'Early_plus' and 'late' treatments, these treatments therefore will have too few comparisons with other treatments in the meta-analysis to be provide accurate results. Therefore we will remove 'Early_plus' and 'Late' from the analysis.  


```{r simpler_clusters_REMOVE}

slimmer_PM_dat <- slim_PM_dat[slim_PM_dat$spray_management != "Late" & 
               slim_PM_dat$spray_management != "Early_plus",]

write.csv(slimmer_PM_dat, file = "data/slimmer_PM_clusterdat.csv", row.names = FALSE)
```

Our data currently uses sample variance to define the yield error. We should expect that when yield increases so does the variance. Lets quickly plot this to check.

```{r Var_mean_sqaures}
# redefine sample variance calculated from mean square
slimmer_PM_dat$vi <- 
   slimmer_PM_dat$Y_Msquare / 
   (slimmer_PM_dat$n * slimmer_PM_dat$grain_yield.t.ha ^ 2)

slimmer_PM_dat %>%
   ggplot(aes(x= grain_yield.t.ha, y = vi))+
   geom_point()
```

We see here that the sample variance generally decreases or has no association with the grain yield. This might be due to the unpredictable nature of mungbeans, however going forward we will use mean squares which defines between trial variation and is a the more generic error term.  

```{r Var_MeanSquarePlot}
slimmer_PM_dat %>%
   ggplot(aes(x= grain_yield.t.ha, y = Y_Msquare))+
   geom_point()

```

